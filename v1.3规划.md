# DAOKit v1.3 / v1.4 联合规划（调整版）

## 1. 规划背景

### 1.1 已在进行中的版本
- v1.1：Tooling/Verification Hardening。
- v1.2：Reliability/Operator Experience。

两者继续按既定路线执行，不在本规划中打断或改目标。

### 1.2 本次调整结论
原 v1.3 范围过大（P0+P1+P2+P3+P4），实施风险和堆积风险过高。调整为两阶段：
- v1.3：只做 Real Workload Proof（P0 + P1）
- v1.4：再做 Deep Integration（P2 + P3）

### 1.3 DKT-056 冻结结论（Wave 0）
1. v1.3 范围冻结为 P0 + P1，v1.4 的 P2/P3 不纳入 v1.3 执行与验收。
2. 可复现语义冻结为“流程与结构一致”：
   - 状态转移路径一致；
   - 工具调用序列形状一致；
   - artifact 结构与关键字段一致；
   - 允许 LLM 文本内容差异。
3. 兼容与运行时不变式冻结：
   - CLI 对外参数名不变；
   - `schema_version=1.0.0` 语义不变；
   - `v1.0.0-rc1` 与 `docs/reports/final-run/` 结构不变；
   - LangGraph 默认，legacy 仅维护不扩展。
4. 冻结审计基线见：
   - `specs/006-v1-3-real-workload-proof/guardrail-charter-acceptance-matrix.md`

## 2. 版本拆分原则

1. 先证明“系统能完成真实任务”，再证明“架构深度与可扩展性”。
2. 强耦合项放同版本：P0（真实链路）与 P1（真实 embedding）一起推进。
3. 架构升级项后置：P2（LangGraph 深化）与 P3（SQLite 后端）进入 v1.4。
4. 展示材料（原 P4）不作为正式版本波次，放在 v1.4 完成后的整理阶段。

## 3. v1.3 规划（Real Workload Proof）

## 3.1 版本目标
用最小但真实的端到端流程，证明 DAOKit 不只是“骨架可运行”，而是“能完成真实任务且证据可审计”。

## 3.2 范围（In Scope）

### P0：最小真实端到端场景（单 Agent）
最小场景定义：
- 输入：一段文本任务描述（不强依赖 GitHub API）。
- 流程：planner 拆解为 2-3 步 -> 单个 coding agent 执行 -> acceptance 验收。
- 输出：生成文件 + `report.md` + `verification.log` + `audit-summary.md`。

验收定义（修正“可复现”冲突）：
1. 流程可复现：相同输入触发相同状态转移路径与工具调用序列。
2. 产物结构可比对：artifact 目录结构和关键字段一致，允许 LLM 文本内容差异。
3. 证据可审计：`events.jsonl` 完整记录调用链路与关键决策。

### P1：真实 embedding 集成 + 检索评测
实施要求：
1. 先抽象 `EmbeddingProvider` 接口，避免模型/厂商绑死。
2. 生产路径接入真实 embedding；测试路径保留 deterministic fixture。
3. 进行小规模检索评测（建议 10-20 条 query，度量 top-3 命中率）。

模型策略（不拍脑袋锁死）：
- 本地候选：`BAAI/bge-small-zh-v1.5`（中英友好）
- 本地候选：`sentence-transformers/all-MiniLM-L6-v2`（英文基线）
- API 候选：`text-embedding-3-small`（可选后端）
- 通过评测结果决定默认模型，而非预先硬编码。

## 3.3 非范围（Out of Scope）
- 多 Agent review/PR 自动提交流程（延后）。
- LangGraph 并行分支、人审节点、checkpoint 深化（放 v1.4/v1.5）。
- SQLite 后端（放 v1.4）。
- 任意 v1.4 P2/P3 实现工作（在 v1.3 中一律不执行）。

## 3.4 波次规划
1. Wave 0：规格冻结（范围、验收口径、兼容红线）。
2. Wave 1：P0 最小端到端单 Agent 链路。
3. Wave 2：P1 embedding provider + 模型评测 + 默认模型决策。
4. Wave 3：集成验收、合并、`tag v1.3.0`。

## 3.5 版本交付物
- v1.3 requirements/design/tasks。
- 最小真实 E2E 场景与证据包。
- embedding provider 抽象与检索评测报告。

## 4. v1.4 规划（Deep Integration）

## 4.1 版本目标
在已有真实 workload 的前提下，证明编排能力深度与状态层可扩展性。

## 4.2 范围（In Scope）

### P2：LangGraph 深化（v1.4 只做两项）
- Conditional edges（动态路由）
- Checkpoint/Resume（原生恢复）

说明：
- `parallel branches` 与 `human-in-the-loop` 延后到 v1.5，避免一次版本里“浅尝辄止”。

### P3：可插拔持久化后端（SQLite）
- 抽象 `StateBackend`。
- 保留文件系统后端。
- 新增 SQLite 后端并通过一致性验证。

## 4.3 非范围（Out of Scope）
- parallel branches / human-in-the-loop（计划 v1.5）。
- 展示包装材料（不作为版本主线交付）。

## 4.4 波次规划
1. Wave 0：规格冻结（DKT-064，LangGraph 深化边界 + 后端一致性标准；仅文档/验证，不做集成执行）。
2. Wave 1：P2 conditional edges + checkpoint/resume。
3. Wave 2：P3 SQLite 后端 + 跨后端一致性验证。
4. Wave 3：集成验收、合并、`tag v1.4.0`。

## 4.5 版本交付物
- v1.4 范围冻结审计基线：`specs/007-v1-4-deep-integration/guardrail-charter-acceptance-matrix.md`。
- v1.4 requirements/design/tasks。
- LangGraph 深化能力落地与恢复证据。
- SQLite 后端实现与跨后端一致性报告。

## 5. 全局约束与策略（v1.3/v1.4 通用）

1. 不改 CLI 对外参数名（除非有迁移方案并获批）。
2. 不破坏 `schema_version=1.0.0` 契约兼容语义。
3. 不破坏 `v1.0.0-rc1` 发布锚点与 `docs/reports/final-run/` 证据结构。
4. 运行时策略：默认使用 LangGraph runtime；legacy runtime 进入维护模式（保留可用，不新增功能）。
5. 验收仅基于 artifacts 与命令日志，不接受口头声明。
6. `verification.log` 必须保留可机读命令证据（`Command: <cmd>` 与 `=== COMMAND ENTRY N START/END ===`）。

## 6. 执行门禁

1. Wave 0（DKT-056）只做范围冻结和验证，不执行跨波次集成操作。
2. v1.4 Wave 0（DKT-064）同样只做范围冻结和验证，不执行跨波次集成操作。
3. 每波次任务完成后先验收，再合并到 `main`。
4. `push origin main` 成功后才允许进入下一波次。
5. 任一波次失败不跨波次推进，先闭环修复。

## 7. 风险与应对

风险 1：真实 LLM 调用带来结果波动。  
应对：把“可复现”定义为流程一致与结构一致，而非文本逐字一致。

风险 2：embedding 选型争议导致反复。  
应对：先 provider 抽象，再用小评测数据集决策默认模型。

风险 3：LangGraph 深化和后端改造相互干扰。  
应对：拆版本推进，v1.3 先证明 workload，v1.4 再做架构升级。

## 8. v1.4 后续整理（非正式版本波次）

在 v1.4 收口后，再统一整理：
- 面向面试/团队评审的演示脚本与架构图。
- 复盘材料与对外技术叙事。

该部分不占用 v1.3/v1.4 主线开发门禁。
